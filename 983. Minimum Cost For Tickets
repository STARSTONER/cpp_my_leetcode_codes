/* using recurison and memoisation accepted solution, was giving T.L.E without
memoisation */

class Solution {
public:
int t[366];
     int solve(vector<int>&days, vector<int>&costs,int n,int i){
        if(i>=n){
            return 0;// we cant travel anymore so cost
        }

        if(t[i]!=-1){
            return t[i];
        }
            //1_day pass
            int cost_1=costs[0]+solve(days,costs,n,i+1);

            // 2day pass
            int j=i;
            int max_day=days[i]+7;
            while(j<n&& days[j]<max_day){
                j++;
            }
            int cost_7=costs[1]+solve(days,costs,n,j);

            //30_days pass
            j=i;
             max_day=days[i]+30;
             while(j<n&& days[j]<max_day){
                j++;
             }

             int cost_30=costs[2]+solve(days,costs,n,j);

             return t[i]=min({cost_1,cost_7,cost_30});
 
     }

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int n= days.size();

        memset(t,-1,sizeof(t));
        return solve(days, costs,n,0);
    }
};


/* approach 2 using bottom up dp*/

class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        unordered_set<int> st(begin(days),end(days));
        int last_day=days.back();
        vector<int> t(last_day+1,0);
        t[0]=0;
        for(int i=1;i<=last_day;i++){
            //chcek if you hace to travel on ith day or not 
            if(st.find(i)==st.end()){
                t[i]=t[i-1];
                continue;

            }
            t[i]=INT_MAX;
            int day_1_pass=costs[0]+t[max(i-1,0)];

            int day_7_pass=costs[1]+t[max(i-7,0)];
            int day_30_pass=costs[2]+t[(max(i-30,0))];/*// here using max() inside the [] to avoid integer overflow is a very good solution instead of using a if, else for evey condition check*/
// need to remember this simple tip//

            t[i]=min({day_1_pass,day_7_pass,day_30_pass});

        }

        return t[last_day];
    }
};
